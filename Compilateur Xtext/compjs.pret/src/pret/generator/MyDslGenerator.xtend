/*
 * generated by Xtext 2.25.0
 */
package pret.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import pret.myDsl.Commands
import pret.myDsl.Equal

import pret.myDsl.Input
import pret.myDsl.Model
import pret.myDsl.Output
import pret.myDsl.Expression
import pret.myDsl.ExprBase
import pret.myDsl.EBtl
import pret.myDsl.EBsy
import pret.myDsl.EBlist
import pret.myDsl.EBcons
import pret.myDsl.EBhd
import pret.myDsl.LExpr
import org.eclipse.emf.common.util.EList
import java.util.List
import java.util.LinkedList
import java.util.Hashtable
import java.util.Collections
import pret.myDsl.impl.ExprBaseImpl
import pret.services.MyDslGrammarAccess.ExprBaseElements
import java.lang.reflect.Constructor
import org.eclipse.emf.ecore.impl.EStringToStringMapEntryImpl
import pret.myDsl.If
import pret.myDsl.While
import pret.myDsl.For
import pret.myDsl.Foreach
import pret.myDsl.Function
import pret.myDsl.Definition

/*TODO: Faire la table des symbole commune à tout les fichiers
 * 
 * 
 */
/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MyDslGenerator extends AbstractGenerator {

	// liste des fonction
	public static List<Fonction> Lf;

	// Simple Operators
	Op nil = new Op("nil");
	Op nop = new Op("nop");
	Op cons = new Op("cons");
	Op hd = new Op("hd");
	Op tl = new Op("tl");
	Op Beq = new Op("boolEq");

	public static int reg = 0;
	public static Hashtable<String, String> tableSymb = new Hashtable<String, String>();
	public static Hashtable<String, String> tableVar = new Hashtable<String, String>();
	public static int nbVar = 0;
	public static int nbSymb = 0;
	public static List<TAdress> Lad = new LinkedList<TAdress>(); // liste de code 3 adresses principale

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		reg = 0;
		Lad = new LinkedList<TAdress>();
		fsa.generateFile('out.txt', compile(resource.allContents.toIterable.filter(typeof(Model)).get(0)));
		fsa.generateFile('TroisAdr.ta', outList());
	}

	def doGeneratIndent(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context, String outFile) {
		reg = 0;
		Lad = new LinkedList<TAdress>();
		fsa.generateFile('out.js', compile(resource.allContents.toIterable.filter(typeof(Model)).get(0)));
		fsa.generateFile('TroisAdr.ta', outList());
	}

	def outList() {
		var String s = "";
		for (Fonction f : Lf) {
			s += f.outList
		}
		return s
	}

	private def compile(Model m) {
		Lf = new LinkedList<Fonction>();
		Fonction.resetCounter();
		for (Function f : m.func) {
			var Fonction ne = new Fonction(f.fname);
			f.fdef.generateInOut(ne)
			Lf.add(ne); // ajout de la fonction dans la liste principale
		}

		var String rt = "";
		var int i = 0;
		for (Function f : m.func) {
			f.fdef.generateDef(Lf.get(i)); // effets de bords
			rt += Lf.get(i).generateCode();
			rt += "\n"
			i++;
		}
		return rt;
	}

	def generateInOut(Definition d, Fonction f) {
		d.defInput.generateInput(f) // Ajout input dans la fonction créée
	}

	def generateDef(Definition d, Fonction f) {
		// liste 3@ de la fonction actuelle
		var List<TAdress> lt = new LinkedList<TAdress>();

		d.defCommands.generateCommand(lt, f) // Effet de bord
		d.defOutput.generateOutput(f) // Ajout output dans la fonction créée
		f.addAddress(lt); // Ajout des 3@ dans la fonction;
		/*println(tableSymb.toString());
		 *  println(tableVar.toString());
		 * 	var String rt = generateCode();
		 * 	    rt += "//" + tableSymb.toString() + "\n";
		 * 	    rt += "//" + tableVar.toString();
		 * 	    tableSymb.clear();
		 * 	    tableVar.clear();
		 * 	    nbSymb = 0;
		 * 	    nbVar = 0;
		 * 	   return rt;
		 */
	}

// Fonction de gÃ©nÃ©ration du code JS
	/*	def generateCode() {
	 * 		var String rt = "";
	 * 		for (String s : tableVar.values) {
	 * 			rt += "var " + s + ";\n"
	 * 		}
	 * 		for (String s : tableSymb.values) {
	 * 			rt += "var " + s + " = new ArbreBin(\"" + s + "\");\n"
	 * 		}
	 * 		rt += "\n"
	 * 		for (TAdress code : Lad) {
	 * 			rt += code.translate();
	 * 		}
	 * 		return rt;
	 }*/
// Renvoie le string correspondant au sype d'expression (0 pour cons, 1 pour tl et 2 pour hs)
	def typeExprToString(int i) {
		if (i == 0)
			return "\"cons\""
		else if (i == 1)
			return "\"tl\""
		else if(i == 2) return "\"hd\""
	}

// recupere le symbole correponsant au nom initial s en fonction de si c'est un symbole ou une variable
	/* 	def getSymb(String s) {
	 * 		return verifCharMin(s.charAt(0)) ? tableSymb.get(s) : tableVar.get(s);
	 * 	}
	 *  
	 * // ajoute le symbole ou variable correponsant au nom initial s en fonction de si c'est un symbole ou une variable
	 * 	def setSymb(String s) {
	 * 		if (!s.matches("R[0-9]*")) {
	 * 			return verifCharMin(s.charAt(0))
	 * 				? if (!tableSymb.containsKey(s)) {
	 * 				tableSymb.put(s, 's' + nbSymb);
	 * 				nbSymb++;
	 * 			} : if (!tableVar.containsKey(s)) {
	 * 				tableVar.put(s, 'v' + nbVar);
	 * 				nbVar++;
	 * 			};
	 * 		} else {
	 * 			if (!tableVar.containsKey(s)) {
	 * 				tableVar.put(s, 'v' + nbVar);
	 * 				nbVar++;
	 * 			}
	 * 		}
	 }*/
// Fonction qui renvoie si un charactere est en minuscule ou non
	def verifCharMin(char c) {
		var boolean res = c.charValue() >= 97 && c.charValue() <= 122
		return res;
	}

	private def generateInput(Input In, Fonction f) {
		for (String v : In.vai) {
			f.addInput(v)
		}
		if(f.getfName.equals("main")) print(In.vai.length); // cette ligne est importante pour l'interprétation de parametre ça permet de "pipe" avec le script et l'interpréteur de param
	}

	private def generateOutput(Output Out, Fonction f) {
		for (String v : Out.vao) {
			f.addOutput(v)
		}
	}

	private def generateCommand(Commands comms, List<TAdress> lt, Fonction f) {
		for (comm : comms.LCommand) {
			if (comm.eq !== null) {
				comm.eq.generateEq(lt, f);
			}
			if (comm.no !== null) {
				lt.add(new TAdress(nop, "_", "_", "_"));
			}
			if (comm.^if !== null) {
				comm.^if.generateIF(lt, f);
			}
			if (comm.wh !== null) {
				comm.wh.generateWH(lt, f);
			}
			if (comm.fo !== null) {
				comm.fo.generateFO(lt, f);
			}
			if (comm.fore !== null) {
				comm.fore.generateFORE(lt, f);
			}
		}
		return "";
	}

private def generateEq(Equal eq, List<TAdress> lt, Fonction f) {

		var EBsy E = eq.exp.lexpr.get(0).expbg.ebs

		if (E !== null) {
			var Fonction tmp = findFunc(E.sy);
			if (verifyFunc(tmp, E.lexpb.length, eq.vars.lvars.length)) {
				var Op opcall;
				var List<String> lin = new LinkedList<String>();
				var List<String> lout = new LinkedList<String>();
				for (i : 0 ..< E.lexpb.size) {
					lin.add(E.lexpb.get(i).generateExprBase(lt, f)) // on genere les param d'entrée tout en les ajoutant à la liste des entrées
				}
				for (i : 0 ..< eq.vars.lvars.length) {
					lout.add(eq.vars.lvars.get(i)); 
					f.setSymb(eq.vars.lvars.get(i));//TODO:A verifier
				}
				opcall = new OpCall("call", tmp, lin, lout)
				lt.add(new TAdress(opcall, "AM", "_", "_"))

			}
		} else {

			var int max = Math.min(eq.exp.lexpr.length, eq.vars.lvars.length);
			for (var int i = 0; i < max; i++) {
				eq.exp.lexpr.get(i).generateExpression(eq.vars.lvars.get(i), lt, f);
			}
		}
	}

	private def generateIF(If i, List<TAdress> lt, Fonction f) {
		var List<TAdress> co = new LinkedList<TAdress>();
		var List<TAdress> th = new LinkedList<TAdress>();
		var List<TAdress> el = new LinkedList<TAdress>();
		var Op opif;
		var u1 = i.ifexp.generateCondition("R" + reg.toString, co, f);
		reg++;
		i.iflc.generateCommand(th, f);
		if (i.ellc !== null) {
			i.ellc.generateCommand(el, f);
			opif = new OpIt("ifenn", co, th, el);
		} else {
			opif = new OpIt("ifnn", co, th, el);
		}

		lt.add(new TAdress(opif, "_", u1, "_"))

	}

	private def generateWH(While w, List<TAdress> lt, Fonction f) {
		var List<TAdress> co = new LinkedList<TAdress>();
		var List<TAdress> th = new LinkedList<TAdress>();
		var List<TAdress> dummy = new LinkedList<TAdress>();
		var Op opwh;
		var u1 = w.whexp.generateCondition("R" + reg.toString, co, f);
		reg++;
		w.whcom.generateCommand(th, f);

		opwh = new OpIt("whnn", co, th, dummy);

		lt.add(new TAdress(opwh, "_", u1, "_"))
	}

	private def generateFO(For fo, List<TAdress> lt, Fonction f) {
		var List<TAdress> co = new LinkedList<TAdress>();
		var List<TAdress> th = new LinkedList<TAdress>();
		var List<TAdress> dummy = new LinkedList<TAdress>();
		var Op opfo;
		var u1 = fo.foexp.generateCondition("R" + reg.toString, co, f);
		reg++;
		fo.focom.generateCommand(th, f);

		opfo = new OpIt("for", co, th, dummy);

		lt.add(new TAdress(opfo, "_", u1, "_"))
	}

	/**
	 * 	'foreach' forevar=VARIABLE 'in' foreexp=Expression 'do' RCHARIOT* forecom=Commands RCHARIOT* 'od'
	 */
	private def generateFORE(Foreach fr, List<TAdress> lt, Fonction f) {
		var List<TAdress> co = new LinkedList<TAdress>();
		var List<TAdress> th = new LinkedList<TAdress>();
		var List<TAdress> dummy = new LinkedList<TAdress>();
		var Op opfore;

		var u1 = fr.foreexp.generateCondition("R" + reg.toString, co, f);
		reg++;
		fr.forecom.generateCommand(th, f);

		opfore = new OpIt("foreach", co, th, dummy);

		lt.add(new TAdress(opfore, fr.forevar, u1, "_"))
		f.setSymb(fr.forevar);
	/* pour l'instant pour le foreach j'ai generer un 3@ comme ça =>
	 * foreach X in Y do
	 * ...
	 * od
	 * <=>
	 * <foreach cond then, X, cond.place, _>
	 * 
	 * c'est la position du X qu'on pourra changer au cas ou
	 */
	}

	private def String generateExpression(Expression e, String lvar, List<TAdress> lt, Fonction f) {
		var String u1 = e.expbg.generateExprBase(lt, f); // génération exprBase Droite
		if (e.expbd !== null) {
			var String u2 = e.expbd.generateExprBase(lt, f); // génération exprBase Droite
			lt.add(new TAdress(Beq, lvar, u1, u2))
			f.setSymb(lvar);
			f.setSymb(u1);
			f.setSymb(u2);
		} else {
			var Op o = new Opsymb("const", u1);
			lt.add(new TAdress(o, lvar, "_", "_"))
			f.setSymb(lvar);
			f.setSymb(u1);
		}
		return lvar
	}

	private def String generateCondition(Expression e, String lvar, List<TAdress> lt, Fonction f) {
		if (e.expbd !== null) {
			reg++;
			var String u1 = e.expbg.generateExprBase(lt, f); // génération exprBase Droite
			var String u2 = e.expbd.generateExprBase(lt, f); // génération exprBase Droite
			lt.add(new TAdress(Beq, lvar, u1, u2))
			f.setSymb(lvar);
			f.setSymb(u1);
			f.setSymb(u2);
		} else {
			var String u1 = e.expbg.generateExprBase(lt, f); // génération exprBase Droite
			var Op o = new Opsymb("const", u1);
			lt.add(new TAdress(o, lvar, "_", "_"))
			f.setSymb(lvar);
			f.setSymb(u1);
		}
		return lvar
	}

	private def String generateExprBase(ExprBase eb, List<TAdress> lt, Fonction f) {
		if (eb.v !== null) {
			// reg++
			// Lad.add(new TAdress("const " + eb.v, "R" + reg.toString, "_", "_"));
			f.setSymb(eb.v);
			// setSymb("R" + reg.toString);
			return eb.v
		}

		if (eb.sy !== null) {
			// reg++
			// Lad.add(new TAdress("const " + eb.sy, "R" + reg.toString, "_", "_"))
			// setSymb("R" + reg.toString);
			f.setSymb(eb.sy);
			return eb.sy
		}

		if (eb.ni !== null) {
			lt.add(new TAdress(nil, "R" + reg.toString, "_", "_"))
			f.setSymb("R" + reg.toString);
			reg++
			return "R" + (reg - 1).toString
		}

		if (eb.ebt !== null) {
			var String u = eb.ebt.expb.generateExprBase(lt, f);

			lt.add(new TAdress(tl, "R" + reg.toString, u, "_"))
			f.setSymb("R" + reg.toString);
			f.setSymb(u);
			reg++;
			return "R" + (reg - 1).toString
		}
		if (eb.ebh !== null) {
			var String u = eb.ebh.expb.generateExprBase(lt, f)
			lt.add(new TAdress(hd, "R" + reg.toString, u, "_"))
			f.setSymb("R" + reg.toString);
			f.setSymb(u);
			reg++;
			return "R" + (reg - 1).toString
		}
		if (eb.ebc !== null) {
			var String u = eb.ebc.lexpb.generateEBcons("R" + reg.toString, lt, f)
			f.setSymb(u);
			return u
		}
		if (eb.ebl !== null) {
			val ExprBase X = new MyExprBase("nil", "nil"); // j'ai ajoutÃ© moi meme ce constructeur pour pouvoir ajouter manuellement des instance de ExprBase
			eb.ebl.lexpb.add(X);
			var String u = eb.ebl.lexpb.generateEBcons("R" + reg.toString, lt, f);
			f.setSymb(u);
			return u

		}
		if (eb.ebs !== null) {
			var String u;
			var Fonction tmp = findFunc(eb.ebs.sy);
			if (verifyFunc(tmp, eb.ebs.lexpb.size, 1)) { // TODO: changer le 1?
				var List<TAdress> param = new LinkedList<TAdress>();
				var Op opcall;
				var List<String> l = new LinkedList<String>();
				for (i : 0 ..< eb.ebs.lexpb.size) {
					l.add(eb.ebs.lexpb.get(i).generateExprBase(lt, f)) // on genere les param d'entrée tout en les ajout à la liste des entrées
				}
				opcall = new OpCall("call", tmp, l)
				lt.add(new TAdress(opcall, "R" + reg.toString, "_", "_"))
				return "R" + (reg).toString;
			} else {
				val ExprBase X = new MyExprBase("symb", eb.ebs.sy);
				eb.ebs.lexpb.add(0, X);
				u = eb.ebs.lexpb.generateEBcons("R" + reg.toString, lt, f);
				f.setSymb(u);
			}

			return u

		}
	}

	/**
	 * Fonction de vérification d'une fonction
	 * @input f : la fonction
	 * @input lgIn : Le nombre de paramètre d'entrée
	 * @input lgOut: Le nombre de paramètre de sortie
	 * @return boolean : si la fonction existe et que le nombre de paramètre correspond bien
	 * 
	 */
	private def verifyFunc(Fonction f, int lgIn, int lgOut) {
		if (f !== null) {
			if(f.lgIn != lgIn) return false
			if(f.lgOut != lgOut) return false
			return true
		}
	}

	private def findFunc(String name) {
		for (var int i = 0; i < Lf.size; i++) {
			if (Lf.get(i).formerName.equals(name)) {
				return Lf.get(i);
			}
		}
		return null
	}

	private def String generateEBcons(
		EList<ExprBase> s,
		String supReg,
		List<TAdress> lt,
		Fonction f
	) {
		if (s.size == 0) {
			lt.add(new TAdress(cons, supReg, "_", "_"))
		} else if (s.size == 1) {
			var u = s.get(0).generateExprBase(lt, f)
			lt.add(new TAdress(cons, supReg, u, "_"))
			f.setSymb(u);
		} else {
			var List<String> l = new LinkedList<String>();
			// on gÃ©nÃ¨re tout les ExprBase dans le cons courrant  et en meme temps on creer une liste des nom de variables.Symboles/registres qu'on rÃ©cupÃ¨re
			for (i : 0 ..< s.size) {
				l.add(s.get(i).generateExprBase(lt, f))
			}
			while (l.size > 1) {
				if (l.size == 2) {
					var String tmp1 = l.remove(l.size - 1)
					var String tmp2 = l.remove(l.size - 1)
					lt.add(new TAdress(cons, supReg, tmp2, tmp1)) // on recupere les deux truc restant et on les mets dans un adresse
					f.setSymb(tmp1);
					f.setSymb(tmp2);
					f.setSymb("R" + reg.toString);
				} else {
					var String tmp1 = l.remove(l.size - 1)
					var String tmp2 = l.remove(l.size - 1)
					lt.add(new TAdress(cons, "R" + reg.toString, tmp2, tmp1))
					l.add("R" + reg.toString)
					f.setSymb(tmp1);
					f.setSymb(tmp2);
					f.setSymb("R" + reg.toString);
				}
			}
		}
		reg++;
		return supReg
	}
}
