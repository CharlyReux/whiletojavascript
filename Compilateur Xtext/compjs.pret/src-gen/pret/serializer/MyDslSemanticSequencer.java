/*
 * generated by Xtext 2.25.0
 */
package pret.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import pret.myDsl.Command;
import pret.myDsl.Commands;
import pret.myDsl.Definition;
import pret.myDsl.EBcons;
import pret.myDsl.EBhd;
import pret.myDsl.EBlist;
import pret.myDsl.EBsy;
import pret.myDsl.EBtl;
import pret.myDsl.Equal;
import pret.myDsl.ExprBase;
import pret.myDsl.Expression;
import pret.myDsl.Exprs;
import pret.myDsl.For;
import pret.myDsl.Foreach;
import pret.myDsl.Function;
import pret.myDsl.If;
import pret.myDsl.Input;
import pret.myDsl.LExpr;
import pret.myDsl.Model;
import pret.myDsl.MyDslPackage;
import pret.myDsl.Output;
import pret.myDsl.Vars;
import pret.myDsl.While;
import pret.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.COMMAND:
				sequence_Command(context, (Command) semanticObject); 
				return; 
			case MyDslPackage.COMMANDS:
				sequence_Commands(context, (Commands) semanticObject); 
				return; 
			case MyDslPackage.DEFINITION:
				sequence_Definition(context, (Definition) semanticObject); 
				return; 
			case MyDslPackage.EBCONS:
				sequence_EBcons(context, (EBcons) semanticObject); 
				return; 
			case MyDslPackage.EBHD:
				sequence_EBhd(context, (EBhd) semanticObject); 
				return; 
			case MyDslPackage.EBLIST:
				sequence_EBlist(context, (EBlist) semanticObject); 
				return; 
			case MyDslPackage.EBSY:
				sequence_EBsy(context, (EBsy) semanticObject); 
				return; 
			case MyDslPackage.EBTL:
				sequence_EBtl(context, (EBtl) semanticObject); 
				return; 
			case MyDslPackage.EQUAL:
				sequence_Equal(context, (Equal) semanticObject); 
				return; 
			case MyDslPackage.EXPR_BASE:
				sequence_ExprBase(context, (ExprBase) semanticObject); 
				return; 
			case MyDslPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case MyDslPackage.EXPRS:
				sequence_Exprs(context, (Exprs) semanticObject); 
				return; 
			case MyDslPackage.FOR:
				sequence_For(context, (For) semanticObject); 
				return; 
			case MyDslPackage.FOREACH:
				sequence_Foreach(context, (Foreach) semanticObject); 
				return; 
			case MyDslPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case MyDslPackage.IF:
				sequence_If(context, (If) semanticObject); 
				return; 
			case MyDslPackage.INPUT:
				sequence_Input(context, (Input) semanticObject); 
				return; 
			case MyDslPackage.LEXPR:
				sequence_LExpr(context, (LExpr) semanticObject); 
				return; 
			case MyDslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MyDslPackage.OUTPUT:
				sequence_Output(context, (Output) semanticObject); 
				return; 
			case MyDslPackage.VARS:
				sequence_Vars(context, (Vars) semanticObject); 
				return; 
			case MyDslPackage.WHILE:
				sequence_While(context, (While) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Command returns Command
	 *
	 * Constraint:
	 *     (
	 *         eq=Equal | 
	 *         no='nop' | 
	 *         if=If | 
	 *         wh=While | 
	 *         fo=For | 
	 *         fore=Foreach
	 *     )
	 */
	protected void sequence_Command(ISerializationContext context, Command semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Commands returns Commands
	 *
	 * Constraint:
	 *     (LCommand+=Command LCommand+=Command*)
	 */
	protected void sequence_Commands(ISerializationContext context, Commands semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns Definition
	 *
	 * Constraint:
	 *     (defInput=Input defCommands=Commands defOutput=Output)
	 */
	protected void sequence_Definition(ISerializationContext context, Definition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DEFINITION__DEF_INPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DEFINITION__DEF_INPUT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DEFINITION__DEF_COMMANDS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DEFINITION__DEF_COMMANDS));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DEFINITION__DEF_OUTPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DEFINITION__DEF_OUTPUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefinitionAccess().getDefInputInputParserRuleCall_1_0(), semanticObject.getDefInput());
		feeder.accept(grammarAccess.getDefinitionAccess().getDefCommandsCommandsParserRuleCall_5_0(), semanticObject.getDefCommands());
		feeder.accept(grammarAccess.getDefinitionAccess().getDefOutputOutputParserRuleCall_9_0(), semanticObject.getDefOutput());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EBcons returns EBcons
	 *
	 * Constraint:
	 *     lexpb+=ExprBase*
	 */
	protected void sequence_EBcons(ISerializationContext context, EBcons semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EBhd returns EBhd
	 *
	 * Constraint:
	 *     expb=ExprBase
	 */
	protected void sequence_EBhd(ISerializationContext context, EBhd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EBHD__EXPB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EBHD__EXPB));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEBhdAccess().getExpbExprBaseParserRuleCall_2_0(), semanticObject.getExpb());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EBlist returns EBlist
	 *
	 * Constraint:
	 *     lexpb+=ExprBase*
	 */
	protected void sequence_EBlist(ISerializationContext context, EBlist semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EBsy returns EBsy
	 *
	 * Constraint:
	 *     (sy=SYMBOL lexpb+=ExprBase*)
	 */
	protected void sequence_EBsy(ISerializationContext context, EBsy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EBtl returns EBtl
	 *
	 * Constraint:
	 *     expb=ExprBase
	 */
	protected void sequence_EBtl(ISerializationContext context, EBtl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EBTL__EXPB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EBTL__EXPB));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEBtlAccess().getExpbExprBaseParserRuleCall_2_0(), semanticObject.getExpb());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Equal returns Equal
	 *
	 * Constraint:
	 *     (vars=Vars exp=Exprs)
	 */
	protected void sequence_Equal(ISerializationContext context, Equal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EQUAL__VARS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EQUAL__VARS));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EQUAL__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EQUAL__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualAccess().getVarsVarsParserRuleCall_0_0(), semanticObject.getVars());
		feeder.accept(grammarAccess.getEqualAccess().getExpExprsParserRuleCall_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExprBase returns ExprBase
	 *
	 * Constraint:
	 *     (
	 *         ni='nil' | 
	 *         v=VARIABLE | 
	 *         sy=SYMBOL | 
	 *         ebt=EBtl | 
	 *         ebh=EBhd | 
	 *         ebc=EBcons | 
	 *         ebl=EBlist | 
	 *         ebs=EBsy
	 *     )
	 */
	protected void sequence_ExprBase(ISerializationContext context, ExprBase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     (expbg=ExprBase expbd=ExprBase?)
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Exprs returns Exprs
	 *
	 * Constraint:
	 *     (lexpr+=Expression lexpr+=Expression*)
	 */
	protected void sequence_Exprs(ISerializationContext context, Exprs semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     For returns For
	 *
	 * Constraint:
	 *     (foexp=Expression focom=Commands)
	 */
	protected void sequence_For(ISerializationContext context, For semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FOR__FOEXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FOR__FOEXP));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FOR__FOCOM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FOR__FOCOM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForAccess().getFoexpExpressionParserRuleCall_1_0(), semanticObject.getFoexp());
		feeder.accept(grammarAccess.getForAccess().getFocomCommandsParserRuleCall_4_0(), semanticObject.getFocom());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Foreach returns Foreach
	 *
	 * Constraint:
	 *     (forevar=VARIABLE foreexp=Expression forecom=Commands)
	 */
	protected void sequence_Foreach(ISerializationContext context, Foreach semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FOREACH__FOREVAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FOREACH__FOREVAR));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FOREACH__FOREEXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FOREACH__FOREEXP));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FOREACH__FORECOM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FOREACH__FORECOM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForeachAccess().getForevarVARIABLETerminalRuleCall_1_0(), semanticObject.getForevar());
		feeder.accept(grammarAccess.getForeachAccess().getForeexpExpressionParserRuleCall_3_0(), semanticObject.getForeexp());
		feeder.accept(grammarAccess.getForeachAccess().getForecomCommandsParserRuleCall_6_0(), semanticObject.getForecom());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (fname=SYMBOL fdef=Definition)
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FUNCTION__FNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FUNCTION__FNAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FUNCTION__FDEF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FUNCTION__FDEF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionAccess().getFnameSYMBOLTerminalRuleCall_1_0(), semanticObject.getFname());
		feeder.accept(grammarAccess.getFunctionAccess().getFdefDefinitionParserRuleCall_3_0(), semanticObject.getFdef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     If returns If
	 *
	 * Constraint:
	 *     (ifexp=Expression iflc=Commands ellc=Commands?)
	 */
	protected void sequence_If(ISerializationContext context, If semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Input returns Input
	 *
	 * Constraint:
	 *     (vai+=VARIABLE vai+=VARIABLE*)
	 */
	protected void sequence_Input(ISerializationContext context, Input semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LExpr returns LExpr
	 *
	 * Constraint:
	 *     (Lexpb+=ExprBase Lexpb+=ExprBase*)
	 */
	protected void sequence_LExpr(ISerializationContext context, LExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     func+=Function+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Output returns Output
	 *
	 * Constraint:
	 *     (vao+=VARIABLE vao+=VARIABLE*)
	 */
	protected void sequence_Output(ISerializationContext context, Output semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Vars returns Vars
	 *
	 * Constraint:
	 *     (lvars+=VARIABLE lvars+=VARIABLE*)
	 */
	protected void sequence_Vars(ISerializationContext context, Vars semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     While returns While
	 *
	 * Constraint:
	 *     (whexp=Expression whcom=Commands)
	 */
	protected void sequence_While(ISerializationContext context, While semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.WHILE__WHEXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.WHILE__WHEXP));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.WHILE__WHCOM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.WHILE__WHCOM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileAccess().getWhexpExpressionParserRuleCall_1_0(), semanticObject.getWhexp());
		feeder.accept(grammarAccess.getWhileAccess().getWhcomCommandsParserRuleCall_4_0(), semanticObject.getWhcom());
		feeder.finish();
	}
	
	
}
