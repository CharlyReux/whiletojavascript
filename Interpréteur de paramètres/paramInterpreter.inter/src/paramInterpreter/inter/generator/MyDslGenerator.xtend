/*
 * generated by Xtext 2.25.0
 */
package paramInterpreter.inter.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import paramInterpreter.inter.myDsl.ExprBase
import org.eclipse.emf.common.util.EList
import java.util.List
import java.util.LinkedList
import java.util.Hashtable
import paramInterpreter.inter.myDsl.Model
import paramInterpreter.inter.myDsl.Equal
import paramInterpreter.inter.myDsl.Expression

//import paramInterpreter.inter.generator.TAdress
/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MyDslGenerator extends AbstractGenerator {

	// Simple Operators
	Op nil = new Op("nil");
	Op cons = new Op("cons");
	Op hd = new Op("hd");
	Op tl = new Op("tl");
	Op Beq = new Op("boolEq");

	public static int reg = 0;
	public static Hashtable<String, String> tableSymb = new Hashtable<String, String>();
	public static Hashtable<String, String> tableVar = new Hashtable<String, String>();
	public static int nbVar = 0;
	public static int nbSymb = 0;
	public static List<TAdress> Lad = new LinkedList<TAdress>(); // liste de code 3 adresses principale

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		reg = 0;
		Lad = new LinkedList<TAdress>();
		fsa.generateFile('listParam.js', compile(resource.allContents.toIterable.filter(typeof(Model)).get(0)));
		fsa.generateFile('TroisAdr.ta', outList());
	}

	def doGeneratIndent(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		reg = 0;
		Lad = new LinkedList<TAdress>();
		fsa.generateFile('listParam.js', compile(resource.allContents.toIterable.filter(typeof(Model)).get(0)));
		fsa.generateFile('TroisAdr.ta', outList());
	}

	def outList() {
		var String s = "";
		for (TAdress TA : Lad) {
			s += TA.toString()
		}
		return s
	}

	private def compile(Model m) {
		var int nbIn=1
		for (Equal e : m.eqListe) {
			tableVar.put("In"+ nbIn, "In" + nbIn);
			e.generateEq(Lad)
			nbIn++
		}
		var String rt = generateCode();
		/*rt += "//" + tableSymb.toString() + "\n";
		 rt += "//" + tableVar.toString();*/
		rt += "var ret=main(In1"
		for (var int i = 2; i < m.eqListe.length + 1; i++) {
			rt += ",In" + i
		}
		rt += ");\n"
		tableSymb.clear();
		tableVar.clear();
		nbSymb = 0;
		nbVar = 0;
		return rt;
	}

// Fonction de g√©n√©ration du code JS
	def generateCode() {
		var String rt = "";
		for (String s : tableVar.values) {
			rt += "var " + s + ";\n"
		}
		for (String s : tableSymb.values) {
			rt += "var " + s + " = new ArbreBin(\"" + s + "\");\n"
		}
		rt += "\n"
		for (TAdress code : Lad) {
			rt += code.translate(this);
		}
		return rt;
	}

// Renvoie le string correspondant au sype d'expression (0 pour cons, 1 pour tl et 2 pour hs)
	def typeExprToString(int i) {
		if (i == 0)
			return "\"cons\""
		else if (i == 1)
			return "\"tl\""
		else if(i == 2) return "\"hd\""
	}

// recupere le symbole correponsant au nom initial s en fonction de si c'est un symbole ou une variable
	def getSymb(String s) {
		return verifCharMin(s.charAt(0)) ? tableSymb.get(s) : tableVar.get(s);
	}

// ajoute le symbole ou variable correponsant au nom initial s en fonction de si c'est un symbole ou une variable
	def setSymb(String s) {
		if (!s.matches("R[0-9]*")) {
			return verifCharMin(s.charAt(0))
				? if (!tableSymb.containsKey(s)) {
				tableSymb.put(s, 's' + nbSymb);
				nbSymb++;
			} : if (!tableVar.containsKey(s)) {
				tableVar.put(s, 'v' + nbVar);
				nbVar++;
			};
		} else {
			if (!tableVar.containsKey(s)) {
				tableVar.put(s, 'v' + nbVar);
				nbVar++;
			}
		}
	}

// Fonction qui renvoie si un charactere est en minuscule ou non
	def verifCharMin(char c) {
		var boolean res = c.charValue() >= 97 && c.charValue() <= 122
		return res;
	}

	private def String toStringLad(List<TAdress> lt) {
		var String rt = ""
		for (TAdress T : lt) {
			rt += T.toString
		}
		return rt
	}

	private def generateEq(Equal eq, List<TAdress> lt) {

		eq.exp.lexpr.generateExpression(eq.vars.lvars, lt);

	}

	private def String generateExpression(Expression e, String lvar, List<TAdress> lt) {
		var String u1 = e.expbg.generateExprBase(lt); // gÈnÈration exprBase Droite
		if (e.expbd !== null) {
			var String u2 = e.expbd.generateExprBase(lt); // gÈnÈration exprBase Droite
			lt.add(new TAdress(Beq, lvar, u1, u2))
			setSymb(u1);
			setSymb(u2);
		} else {
			var Op o = new Opsymb("const", u1);
			lt.add(new TAdress(o, lvar, "_", "_"))
			setSymb(u1);
		}
		return lvar
	}

	private def String generateExprBase(ExprBase eb, List<TAdress> lt) {
		if (eb.v !== null) {
			// reg++
			// Lad.add(new TAdress("const " + eb.v, "R" + reg.toString, "_", "_"));
			setSymb(eb.v);
			// setSymb("R" + reg.toString);
			return eb.v
		}

		if (eb.sy !== null) {
			// reg++
			// Lad.add(new TAdress("const " + eb.sy, "R" + reg.toString, "_", "_"))
			// setSymb("R" + reg.toString);
			setSymb(eb.sy);
			return eb.sy
		}

		if (eb.ni !== null) {
			lt.add(new TAdress(nil, "R" + reg.toString, "_", "_"))
			setSymb("R" + reg.toString);
			reg++
			return "R" + (reg - 1).toString
		}

		if (eb.ebt !== null) {
			var String u = eb.ebt.expb.generateExprBase(lt);

			lt.add(new TAdress(tl, "R" + reg.toString, u, "_"))
			setSymb("R" + reg.toString);
			setSymb(u);
			reg++;
			return "R" + (reg - 1).toString
		}
		if (eb.ebh !== null) {
			var String u = eb.ebh.expb.generateExprBase(lt)
			lt.add(new TAdress(hd, "R" + reg.toString, u, "_"))
			setSymb("R" + reg.toString);
			setSymb(u);
			reg++;
			return "R" + (reg - 1).toString
		}
		if (eb.ebc !== null) {
			var String u = eb.ebc.lexpb.generateEBcons("R" + reg.toString, lt)
			setSymb(u);
			return u
		}
		if (eb.ebl !== null) {
			val ExprBase X = new MyExprBase("nil", "nil"); // j'ai ajout√© moi meme ce constructeur pour pouvoir ajouter manuellement des instance de ExprBase
			eb.ebl.lexpb.add(X);
			var String u = eb.ebl.lexpb.generateEBcons("R" + reg.toString, lt);
			setSymb(u);
			return u

		}
		if (eb.ebs !== null) {
			val ExprBase X = new MyExprBase("symb", eb.ebs.sy);
			eb.ebs.lexpb.add(0, X);
			var String u = eb.ebs.lexpb.generateEBcons("R" + reg.toString, lt);
			setSymb(u);
			return u

		}
	}

	private def String generateEBcons(
		EList<ExprBase> s,
		String supReg,
		List<TAdress> lt
	) {
		if (s.size == 0) {
			lt.add(new TAdress(cons, supReg, "_", "_"))
		} else if (s.size == 1) {
			var u = s.get(0).generateExprBase(lt)
			lt.add(new TAdress(cons, supReg, u, "_"))
			setSymb(u);
		} else {
			var List<String> l = new LinkedList<String>();
			// on g√©n√®re tout les ExprBase dans le cons courrant  et en meme temps on creer une liste des nom de variables.Symboles/registres qu'on r√©cup√®re
			for (i : 0 ..< s.size) {
				l.add(s.get(i).generateExprBase(lt))
			}
			while (l.size > 1) {
				if (l.size == 2) {
					var String tmp1 = l.remove(l.size - 1)
					var String tmp2 = l.remove(l.size - 1)
					lt.add(new TAdress(cons, supReg, tmp2, tmp1)) // on recupere les deux truc restant et on les mets dans un adresse
					setSymb(tmp1);
					setSymb(tmp2);
					setSymb("R" + reg.toString);
				} else {
					var String tmp1 = l.remove(l.size - 1)
					var String tmp2 = l.remove(l.size - 1)
					lt.add(new TAdress(cons, "R" + reg.toString, tmp2, tmp1))
					l.add("R" + reg.toString)
					setSymb(tmp1);
					setSymb(tmp2);
					setSymb("R" + reg.toString);
				}
			}
		}
		reg++;
		return supReg
	}
}
