/*
 * generated by Xtext 2.25.0
 */
package paramInterpreter.inter.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import paramInterpreter.inter.myDsl.EBcons;
import paramInterpreter.inter.myDsl.EBhd;
import paramInterpreter.inter.myDsl.EBlist;
import paramInterpreter.inter.myDsl.EBsy;
import paramInterpreter.inter.myDsl.EBtl;
import paramInterpreter.inter.myDsl.Equal;
import paramInterpreter.inter.myDsl.ExprBase;
import paramInterpreter.inter.myDsl.Expression;
import paramInterpreter.inter.myDsl.Exprs;
import paramInterpreter.inter.myDsl.Model;
import paramInterpreter.inter.myDsl.MyDslPackage;
import paramInterpreter.inter.myDsl.Vars;
import paramInterpreter.inter.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.EBCONS:
				sequence_EBcons(context, (EBcons) semanticObject); 
				return; 
			case MyDslPackage.EBHD:
				sequence_EBhd(context, (EBhd) semanticObject); 
				return; 
			case MyDslPackage.EBLIST:
				sequence_EBlist(context, (EBlist) semanticObject); 
				return; 
			case MyDslPackage.EBSY:
				sequence_EBsy(context, (EBsy) semanticObject); 
				return; 
			case MyDslPackage.EBTL:
				sequence_EBtl(context, (EBtl) semanticObject); 
				return; 
			case MyDslPackage.EQUAL:
				sequence_Equal(context, (Equal) semanticObject); 
				return; 
			case MyDslPackage.EXPR_BASE:
				sequence_ExprBase(context, (ExprBase) semanticObject); 
				return; 
			case MyDslPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case MyDslPackage.EXPRS:
				sequence_Exprs(context, (Exprs) semanticObject); 
				return; 
			case MyDslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MyDslPackage.VARS:
				sequence_Vars(context, (Vars) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     EBcons returns EBcons
	 *
	 * Constraint:
	 *     lexpb+=ExprBase*
	 */
	protected void sequence_EBcons(ISerializationContext context, EBcons semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EBhd returns EBhd
	 *
	 * Constraint:
	 *     expb=ExprBase
	 */
	protected void sequence_EBhd(ISerializationContext context, EBhd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EBHD__EXPB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EBHD__EXPB));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEBhdAccess().getExpbExprBaseParserRuleCall_2_0(), semanticObject.getExpb());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EBlist returns EBlist
	 *
	 * Constraint:
	 *     lexpb+=ExprBase*
	 */
	protected void sequence_EBlist(ISerializationContext context, EBlist semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EBsy returns EBsy
	 *
	 * Constraint:
	 *     (sy=SYMBOL lexpb+=ExprBase*)
	 */
	protected void sequence_EBsy(ISerializationContext context, EBsy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EBtl returns EBtl
	 *
	 * Constraint:
	 *     expb=ExprBase
	 */
	protected void sequence_EBtl(ISerializationContext context, EBtl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EBTL__EXPB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EBTL__EXPB));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEBtlAccess().getExpbExprBaseParserRuleCall_2_0(), semanticObject.getExpb());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Equal returns Equal
	 *
	 * Constraint:
	 *     (vars=Vars exp=Exprs)
	 */
	protected void sequence_Equal(ISerializationContext context, Equal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EQUAL__VARS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EQUAL__VARS));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EQUAL__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EQUAL__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualAccess().getVarsVarsParserRuleCall_0_0(), semanticObject.getVars());
		feeder.accept(grammarAccess.getEqualAccess().getExpExprsParserRuleCall_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExprBase returns ExprBase
	 *
	 * Constraint:
	 *     (
	 *         ni='nil' | 
	 *         v=VARIABLE | 
	 *         sy=SYMBOL | 
	 *         ebt=EBtl | 
	 *         ebh=EBhd | 
	 *         ebc=EBcons | 
	 *         ebl=EBlist | 
	 *         ebs=EBsy
	 *     )
	 */
	protected void sequence_ExprBase(ISerializationContext context, ExprBase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     (expbg=ExprBase expbd=ExprBase?)
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Exprs returns Exprs
	 *
	 * Constraint:
	 *     lexpr=Expression
	 */
	protected void sequence_Exprs(ISerializationContext context, Exprs semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXPRS__LEXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXPRS__LEXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExprsAccess().getLexprExpressionParserRuleCall_0(), semanticObject.getLexpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     eqListe+=Equal+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Vars returns Vars
	 *
	 * Constraint:
	 *     lvars=VARIABLE
	 */
	protected void sequence_Vars(ISerializationContext context, Vars semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.VARS__LVARS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.VARS__LVARS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarsAccess().getLvarsVARIABLETerminalRuleCall_0(), semanticObject.getLvars());
		feeder.finish();
	}
	
	
}
